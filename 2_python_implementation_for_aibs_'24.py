# -*- coding: utf-8 -*-
"""2 Python Implementation for AIBS '24.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1J8FoY0uWJ1_Upl5o7pttejeGDggUDDp7
"""

import numpy as np
import matplotlib.pyplot as plt

num_simulations = 1000
num_die_sides = 37
balances_above_100 = 0

initial_bet_probabilities = [1/37, 4/37, 18/37]
adjusted_bet_probabilities = [2/37, 4/37, 18/37]
bet_rewards = [35, 8, 1]

final_balances = []
rounds_to_zero = []

bet_choices = np.zeros((num_simulations, 3))

for sim in range(num_simulations):

    balance = 100
    alpha = np.ones(3)
    beta = np.ones(3)
    balance_history = [balance]
    rounds = 0

    while balance > 0:
        rounds += 1

        sampled_probabilities = np.random.beta(alpha, beta)

        chosen_bet = np.argmax(sampled_probabilities)

        bet_choices[sim, chosen_bet] += 1

        die_result = np.random.randint(1, num_die_sides + 1)
        bet_probabilities = initial_bet_probabilities
        if rounds > 100 and rounds < 200: #can adjust to fit experiment scheme.
         bet_probabilities = adjusted_bet_probabilities
        else:
          bet_probabilities = initial_bet_probabilities

        if chosen_bet == 0 and die_result <= bet_probabilities[0] * num_die_sides:
            balance += bet_rewards[0]
            alpha[0] += 1
        elif chosen_bet == 1 and die_result <= bet_probabilities[1] * num_die_sides:
            balance += bet_rewards[1]
            alpha[1] += 1
        elif chosen_bet == 2 and die_result % 2 == 0:
            balance += bet_rewards[2]
            alpha[2] += 1
        else:
            balance -= 1
            beta[chosen_bet] += 1

        balance_history.append(balance)

    final_balances.append(balance)
    rounds_to_zero.append(rounds)

average_bet_choices = np.mean(bet_choices, axis=0)
print("Average number of times each bet was chosen:")
print(f"Single number bet: {average_bet_choices[0]}")
print(f"Corner bet: {average_bet_choices[1]}")
print(f"Even bet: {average_bet_choices[2]}")

average_rounds_to_zero = np.mean(rounds_to_zero)
print(f"Average number of rounds to reach zero balance: {average_rounds_to_zero}")

#END OF TS
##############################################################################################################

import numpy as np
import matplotlib.pyplot as plt

num_die_sides = 37
num_simulations = 1000


epsilon = 0.1

final_balances = []
rounds_to_zero = []

bet_choices = np.zeros((num_simulations, 3))

for sim in range(num_simulations):
    balance = 100

    balance_history = [balance]

    bet_probabilities = [1/37, 4/37, 18/37]
    adjusted_bet_probabilities = [2/37, 4/37, 18/37]
    bet_rewards = [35, 8, 1]

    bet_counts = [0, 0, 0]
    bet_wins = [0, 0, 0]

    rounds = 0

    while balance > 0:
        rounds += 1

        if np.random.rand() < epsilon:
            chosen_bet = np.random.choice(3)
        else:
            win_rates = [bet_wins[i] / (bet_counts[i] + 1e-5) for i in range(3)]
            chosen_bet = np.argmax(win_rates)

        bet_choices[sim, chosen_bet] += 1

        die_result = np.random.randint(1, num_die_sides + 1)
        if rounds > 100 and rounds < 200:
            bet_probabilities = adjusted_bet_probabilities
        else:
            bet_probabilities = initial_bet_probabilities
        if chosen_bet == 0 and die_result == 1:
            balance += bet_rewards[0]
            bet_counts[0] += 1
            bet_wins[0] += 1
        elif chosen_bet == 1 and die_result in (2, 4, 35, 37):
            balance += bet_rewards[1]
            bet_counts[1] += 1
            bet_wins[1] += 1
        elif chosen_bet == 2 and die_result % 2 == 0:
            balance += bet_rewards[2]
            bet_counts[2] += 1
            bet_wins[2] += 1
        else:
            bet_counts[chosen_bet] += 1
            balance -= 1

        balance_history.append(balance)

    final_balances.append(balance)
    rounds_to_zero.append(rounds)

    if balance > 100:
        balances_above_100 += 1

average_bet_choices = np.mean(bet_choices, axis=0)
print("Average number of times each bet was chosen:")
print(f"Single number bet: {average_bet_choices[0]}")
print(f"Corner bet: {average_bet_choices[1]}")
print(f"Even bet: {average_bet_choices[2]}")

average_rounds_to_zero = np.mean(rounds_to_zero)
print(f"Average number of rounds to reach zero balance: {average_rounds_to_zero}")

#END OF EPSILON-GREEDY
####################################################################################################################################

import numpy as np
import matplotlib.pyplot as plt

num_die_sides = 37
num_simulations = 1000

epsilon = 1

final_balances = []
rounds_to_zero = []

bet_choices = np.zeros((num_simulations, 3))

for sim in range(num_simulations):

    balance = 100

    balance_history = [balance]

    bet_probabilities = [1/37, 4/37, 18/37]
    adjusted_bet_probabilities = [2/37, 4/37, 18/37]
    bet_rewards = [35, 8, 1]

    bet_counts = [0, 0, 0]
    bet_wins = [0, 0, 0]

    rounds = 0
    if rounds > 100 and rounds < 200:
     bet_probabilities = adjusted_bet_probabilities
    else:
      bet_probabilities = initial_bet_probabilities
    while balance > 0:
        rounds += 1

        if np.random.rand() < epsilon:
            chosen_bet = np.random.choice(3)
        else:
            win_rates = [bet_wins[i] / (bet_counts[i] + 1e-5) for i in range(3)]
            chosen_bet = np.argmax(win_rates)

        bet_choices[sim, chosen_bet] += 1

        die_result = np.random.randint(1, num_die_sides + 1)

        if chosen_bet == 0 and die_result == 1:
            balance += bet_rewards[0]
            bet_counts[0] += 1
            bet_wins[0] += 1
        elif chosen_bet == 1 and die_result in (2, 4, 35, 37):
            balance += bet_rewards[1]
            bet_counts[1] += 1
            bet_wins[1] += 1
        elif chosen_bet == 2 and die_result % 2 == 0:
            balance += bet_rewards[2]
            bet_counts[2] += 1
            bet_wins[2] += 1
        else:
            bet_counts[chosen_bet] += 1
            balance -= 1

        balance_history.append(balance)

    final_balances.append(balance)
    rounds_to_zero.append(rounds)

    if balance > 100:
        balances_above_100 += 1

average_final_balances = np.mean(final_balances)

average_bet_choices = np.mean(bet_choices, axis=0)
print("Average number of times each bet was chosen:")
print(f"Single number bet: {average_bet_choices[0]}")
print(f"Corner bet: {average_bet_choices[1]}")
print(f"Even bet: {average_bet_choices[2]}")

average_rounds_to_zero = np.mean(rounds_to_zero)
print(f"Average number of rounds to reach zero balance: {average_rounds_to_zero}")

#END OF RANDOM GUESSER
##########################################################################################################################################################

import numpy as np
import matplotlib.pyplot as plt

num_simulations = 1000
num_die_sides = 37
balances_above_100 = 0

initial_bet_probabilities = [1/37, 4/37, 18/37]
adjusted_bet_probabilities = [2/37, 4/37, 18/37]
bet_rewards = [35, 8, 1]

final_balances = []
rounds_to_zero = []

bet_choices = np.zeros((num_simulations, 3))

alpha = 0.1
lambda_value = 1

for sim in range(num_simulations):

    balance = 100
    alpha_ts = np.ones(3)
    beta_ts = np.ones(3)
    balance_history = [balance]

    theta = np.zeros(3)
    eligibility_trace = np.zeros(3)

    rounds = 0

    while balance > 0:
        rounds += 1

        if rounds > 100 and rounds < 200:
            bet_probabilities = adjusted_bet_probabilities
        else:
            bet_probabilities = initial_bet_probabilities

        sampled_probabilities = np.random.beta(alpha_ts, beta_ts)

        chosen_bet = np.argmax(sampled_probabilities)

        bet_choices[sim, chosen_bet] += 1

        die_result = np.random.randint(1, num_die_sides + 1)

        if chosen_bet == 0 and die_result == 1:
            reward = bet_rewards[0]
        elif chosen_bet == 1 and die_result in (2, 4, 35, 37):
            reward = bet_rewards[1]
        elif chosen_bet == 2 and die_result % 2 == 0:
            reward = bet_rewards[2]
        else:
            reward = -1

        delta = reward + np.dot(theta, bet_probabilities) - np.dot(theta, [1, 1, 1])

        eligibility_trace = lambda_value * eligibility_trace + bet_probabilities

        theta += alpha * delta * eligibility_trace

        balance += reward

        if reward > 0:
            alpha_ts[chosen_bet] += 1
        else:
            beta_ts[chosen_bet] += 1

        balance_history.append(balance)

    final_balances.append(balance)
    rounds_to_zero.append(rounds)

average_bet_choices = np.mean(bet_choices, axis=0)
print("Average number of times each bet was chosen:")
print(f"Single number bet: {average_bet_choices[0]}")
print(f"Corner bet: {average_bet_choices[1]}")
print(f"Even bet: {average_bet_choices[2]}")

average_rounds_to_zero = np.mean(rounds_to_zero)
print(f"Average number of rounds to reach zero balance: {average_rounds_to_zero}")

#END OF TD-1
##########################################################################################################################################################

import numpy as np
import matplotlib.pyplot as plt

num_simulations = 1000
num_die_sides = 37
balances_above_100 = 0

initial_bet_probabilities = [1/37, 4/37, 18/37]
adjusted_bet_probabilities = [2/37, 4/37, 18/37]
bet_rewards = [35, 8, 1]

final_balances = []
rounds_to_zero = []

bet_choices = np.zeros((num_simulations, 3))

alpha = 0.1
lambda_value = 0

for sim in range(num_simulations):
    balance = 100
    alpha_ts = np.ones(3)
    beta_ts = np.ones(3)
    balance_history = [balance]

    theta = np.zeros(3)
    eligibility_trace = np.zeros(3)

    rounds = 0

    while balance > 0:
        rounds += 1

        if rounds > 100 and rounds < 200:
            bet_probabilities = adjusted_bet_probabilities
        else:
            bet_probabilities = initial_bet_probabilities

        sampled_probabilities = np.random.beta(alpha_ts, beta_ts)

        chosen_bet = np.argmax(sampled_probabilities)

        bet_choices[sim, chosen_bet] += 1

        die_result = np.random.randint(1, num_die_sides + 1)

        if chosen_bet == 0 and die_result == 1:
            reward = bet_rewards[0]
        elif chosen_bet == 1 and die_result in (2, 4, 35, 37):
            reward = bet_rewards[1]
        elif chosen_bet == 2 and die_result % 2 == 0:
            reward = bet_rewards[2]
        else:
            reward = -1

        delta = reward + np.dot(theta, bet_probabilities) - np.dot(theta, [1, 1, 1])

        eligibility_trace = lambda_value * eligibility_trace + bet_probabilities

        theta += alpha * delta * eligibility_trace

        balance += reward

        if reward > 0:
            alpha_ts[chosen_bet] += 1
        else:
            beta_ts[chosen_bet] += 1

        balance_history.append(balance)

    final_balances.append(balance)
    rounds_to_zero.append(rounds)

average_bet_choices = np.mean(bet_choices, axis=0)
print("Average number of times each bet was chosen:")
print(f"Single number bet: {average_bet_choices[0]}")
print(f"Corner bet: {average_bet_choices[1]}")
print(f"Even bet: {average_bet_choices[2]}")

average_rounds_to_zero = np.mean(rounds_to_zero)
print(f"Average number of rounds to reach zero balance: {average_rounds_to_zero}")

#END OF TD-0
################################################################################################################################################################################

import numpy as np
import matplotlib.pyplot as plt

num_simulations = 1000
num_die_sides = 37

initial_bet_probabilities = [1/37, 4/37, 18/37]   # win probabilities
adjusted_bet_probabilities = [2/37, 4/37, 18/37]  # between rounds 1–100
bet_rewards = [35, 8, 1]                          # payout multipliers

final_balances = []
rounds_to_zero = []
bet_choices = np.zeros((num_simulations, 3))

for sim in range(num_simulations):

    balance = 100
    total_rewards = np.zeros(3)
    num_bets_chosen = np.zeros(3)
    balance_history = [balance]
    rounds = 0

    while balance > 0:
        epsilon = 1e-6
        rounds += 1

        # UCB values
        ucb_values = (total_rewards / (num_bets_chosen + epsilon) +
                      3.78* np.sqrt(2 * np.log(rounds + 1) / (num_bets_chosen + epsilon)))
        chosen_bet = np.argmax(ucb_values)
        bet_choices[sim, chosen_bet] += 1

        # Choose which probability set to use
        if 100 < rounds < 200:
            bet_probabilities = initial_bet_probabilities
        else:
            bet_probabilities = initial_bet_probabilities

        # Simulate outcome
        if np.random.rand() < bet_probabilities[chosen_bet]:
            reward = bet_rewards[chosen_bet]   # win payout
        else:
            reward = -1                       # lose 1 unit

        balance += reward
        total_rewards[chosen_bet] += reward
        num_bets_chosen[chosen_bet] += 1

        balance_history.append(balance)

    final_balances.append(balance)
    rounds_to_zero.append(rounds)

# Stats
average_bet_choices = np.mean(bet_choices, axis=0)
print("Average number of times each bet was chosen:")
print(f"Single number bet: {average_bet_choices[0]}")
print(f"Corner bet: {average_bet_choices[1]}")
print(f"Even bet: {average_bet_choices[2]}")

average_rounds_to_zero = np.mean(rounds_to_zero)
print(f"Average number of rounds to reach zero balance: {average_rounds_to_zero}")

#END OF UCB
################################################################################################################################