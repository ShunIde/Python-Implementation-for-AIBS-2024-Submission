# -*- coding: utf-8 -*-
"""1 Python Implementation for AIBS '24.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xsMaxkSLBur_Y4BZ3Y73XcT7IrdWW1hy
"""

import numpy as np
import matplotlib.pyplot as plt

num_simulations = 10000
num_rounds = 500 #change as necessary
num_die_sides = 37
balances_above_100 = 0

bet_probabilities = [1/37, 4/37, 18/37]
bet_rewards = [35, 8, 1]

final_balances = []

bet_choices = np.zeros((num_simulations, 3))

for sim in range(num_simulations):
    balance = 100
    alpha = np.ones(3)
    beta = np.ones(3)
    balance_history = [balance]

    for round in range(num_rounds):
          sampled_probabilities = np.random.beta(alpha, beta)

          chosen_bet = np.argmax(sampled_probabilities)

          bet_choices[sim, chosen_bet] += 1

          die_result = np.random.randint(1, num_die_sides + 1)

          if chosen_bet == 0 and die_result == 1:
              balance += bet_rewards[0]
              alpha[0] += 1
          elif chosen_bet == 1 and die_result in (1, 2, 6, 7):
              balance += bet_rewards[1]
              alpha[1] += 1
          elif chosen_bet == 2 and die_result % 2 == 0:
              balance += bet_rewards[2]
              alpha[2] += 1
          else:
              balance -= 1
              beta[chosen_bet] += 1

          balance_history.append(balance)

    final_balances.append(balance)
    if balance > 100:
        balances_above_100 += 1

average_final_balances = np.mean(final_balances)

squared_differences = np.diff(final_balances) ** 2
mean_squared_difference = np.mean(squared_differences)
root_mean_squared_difference = np.sqrt(mean_squared_difference)

print(f"Average Final Balance Over {num_simulations} Simulations: ${average_final_balances}")
print(f"Frequency of Balances Above $100: {balances_above_100} out of {num_simulations} simulations")
print("Root Mean Squared Difference of Final Balances:", root_mean_squared_difference)

average_bet_choices = np.mean(bet_choices, axis=0)
print("Average number of times each bet was chosen:")
print(f"Single number bet: {average_bet_choices[0]}")
print(f"Corner bet: {average_bet_choices[1]}")
print(f"Even bet: {average_bet_choices[2]}")

import numpy as np
import matplotlib.pyplot as plt


num_rounds = 500 #change as necessary
num_die_sides = 37
num_simulations = 10000
balances_above_100 = 0

epsilon = 0.1

final_balances = []

bet_choices = np.zeros((num_simulations, 3))

for sim in range(num_simulations):
    balance = 100

    balance_history = [balance]

    bet_probabilities = [1/37, 4/37, 18/37]
    bet_rewards = [35, 8, 1]

    bet_counts = [0, 0, 0]
    bet_wins = [0, 0, 0]

    for round_num in range(num_rounds):
        if np.random.rand() < epsilon:
            chosen_bet = np.random.choice(3)
        else:
            win_rates = [bet_wins[i] / (bet_counts[i] + 1e-5) for i in range(3)]
            chosen_bet = np.argmax(win_rates)


        bet_choices[sim, chosen_bet] += 1

        die_result = np.random.randint(1, num_die_sides + 1)

        if chosen_bet == 0 and die_result == 1:
            balance += bet_rewards[0]
            bet_counts[0] += 1
            bet_wins[0] += 1
        elif chosen_bet == 1 and die_result in (2, 4, 35, 37):
            balance += bet_rewards[1]
            bet_counts[1] += 1
            bet_wins[1] += 1
        elif chosen_bet == 2 and die_result % 2 == 0:
            balance += bet_rewards[2]
            bet_counts[2] += 1
            bet_wins[2] += 1
        else:
            bet_counts[chosen_bet] += 1
            balance -= 1

        balance_history.append(balance)

    final_balances.append(balance)

    if balance > 100:
        balances_above_100 += 1

average_final_balances = np.mean(final_balances)

squared_differences = np.diff(final_balances) ** 2
mean_squared_difference = np.mean(squared_differences)
root_mean_squared_difference = np.sqrt(mean_squared_difference)

print(f"Average Final Balance Over {num_simulations} Simulations: ${average_final_balances}")
print(f"Frequency of Balances Above $100: {balances_above_100} out of {num_simulations} simulations")
print("Root Mean Squared Difference of Final Balances:", root_mean_squared_difference)

average_bet_choices = np.mean(bet_choices, axis=0)
print("Average number of times each bet was chosen:")
print(f"Single number bet: {average_bet_choices[0]}")
print(f"Corner bet: {average_bet_choices[1]}")
print(f"Even bet: {average_bet_choices[2]}")

import numpy as np
import matplotlib.pyplot as plt

num_rounds = 500 #change as necessary
num_die_sides = 37
num_simulations = 10000
balances_above_100 = 0

epsilon = 1

final_balances = []

bet_choices = np.zeros((num_simulations, 3))

for sim in range(num_simulations):

    balance = 100

    balance_history = [balance]

    bet_probabilities = [1/37, 4/37, 18/37]
    bet_rewards = [35, 8, 1]

    bet_counts = [0, 0, 0]
    bet_wins = [0, 0, 0]

    for round_num in range(num_rounds):
        if np.random.rand() < epsilon:
            chosen_bet = np.random.choice(3)
        else:
            win_rates = [bet_wins[i] / (bet_counts[i] + 1e-5) for i in range(3)]
            chosen_bet = np.argmax(win_rates)

        bet_choices[sim, chosen_bet] += 1

        die_result = np.random.randint(1, num_die_sides + 1)
        if chosen_bet == 0 and die_result == 1:
            balance += bet_rewards[0]
            bet_counts[0] += 1
            bet_wins[0] += 1
        elif chosen_bet == 1 and die_result in (2, 4, 35, 37):
            balance += bet_rewards[1]
            bet_counts[1] += 1
            bet_wins[1] += 1
        elif chosen_bet == 2 and die_result % 2 == 0:
            balance += bet_rewards[2]
            bet_counts[2] += 1
            bet_wins[2] += 1
        else:
            bet_counts[chosen_bet] += 1
            balance -= 1

        balance_history.append(balance)

    final_balances.append(balance)

    if balance > 100:
        balances_above_100 += 1

average_final_balances = np.mean(final_balances)

squared_differences = np.diff(final_balances) ** 2
mean_squared_difference = np.mean(squared_differences)
root_mean_squared_difference = np.sqrt(mean_squared_difference)

print(f"Average Final Balance Over {num_simulations} Simulations: ${average_final_balances}")
print(f"Frequency of Balances Above $100: {balances_above_100} out of {num_simulations} simulations")
print("Root Mean Squared Difference of Final Balances:", root_mean_squared_difference)

average_bet_choices = np.mean(bet_choices, axis=0)
print("Average number of times each bet was chosen:")
print(f"Single number bet: {average_bet_choices[0]}")
print(f"Corner bet: {average_bet_choices[1]}")
print(f"Even bet: {average_bet_choices[2]}")

import numpy as np
import matplotlib.pyplot as plt

num_simulations = 10000
num_rounds = 500 #change as necessary
num_die_sides = 37
balances_above_100 = 0

bet_probabilities = [1/37, 4/37, 18/37]
bet_rewards = [35, 8, 1]

final_balances = []

bet_choices = np.zeros((num_simulations, 3))

alpha = 0.1
lambda_value = 0

for sim in range(num_simulations):
    balance = 100
    alpha = np.ones(3)
    beta = np.ones(3)
    balance_history = [balance]

    theta = np.zeros(3)
    eligibility_trace = np.zeros(3)

    for _ in range(num_rounds):
        sampled_probabilities = np.random.beta(alpha, beta)

        chosen_bet = np.argmax(sampled_probabilities)

        bet_choices[sim, chosen_bet] += 1

        die_result = np.random.randint(1, num_die_sides + 1)

        if chosen_bet == 0 and die_result == 1:
            reward = bet_rewards[0]
        elif chosen_bet == 1 and die_result in (1, 2, 6, 7):
            reward = bet_rewards[1]
        elif chosen_bet == 2 and die_result % 2 == 0:
            reward = bet_rewards[2]
        else:
            reward = -1

        delta = reward + np.dot(theta, bet_probabilities) - np.dot(theta, [1, 1, 1])

        eligibility_trace = lambda_value * eligibility_trace + bet_probabilities

        theta += alpha * delta * eligibility_trace

        balance += reward

        if reward > 0:
            alpha[chosen_bet] += 1
        else:
            beta[chosen_bet] += 1

        balance_history.append(balance)

    final_balances.append(balance)

    if balance > 100:
        balances_above_100 += 1

average_final_balances = np.mean(final_balances)

squared_differences = np.diff(final_balances) ** 2
mean_squared_difference = np.mean(squared_differences)
root_mean_squared_difference = np.sqrt(mean_squared_difference)

print(f"Average Final Balance Over {num_simulations} Simulations: ${average_final_balances}")
print(f"Frequency of Balances Above $100: {balances_above_100} out of {num_simulations} simulations")
print("Root Mean Squared Difference of Final Balances:", root_mean_squared_difference)

average_bet_choices = np.mean(bet_choices, axis=0)
print("Average number of times each bet was chosen:")
print(f"Single number bet: {average_bet_choices[0]}")
print(f"Corner bet: {average_bet_choices[1]}")
print(f"Even bet: {average_bet_choices[2]}")

import numpy as np
import matplotlib.pyplot as plt

num_simulations = 10000
num_rounds = 500 #change as necessary
num_die_sides = 37
balances_above_100 = 0

bet_probabilities = [1/37, 4/37, 18/37]
bet_rewards = [35, 8, 1]

final_balances = []

bet_choices = np.zeros((num_simulations, 3))

alpha = 0.1
lambda_value = 1

for sim in range(num_simulations):
    balance = 100
    alpha = np.ones(3)
    beta = np.ones(3)
    balance_history = [balance]

    theta = np.zeros(3)
    eligibility_trace = np.zeros(3)

    for _ in range(num_rounds):
        sampled_probabilities = np.random.beta(alpha, beta)

        chosen_bet = np.argmax(sampled_probabilities)

        bet_choices[sim, chosen_bet] += 1

        die_result = np.random.randint(1, num_die_sides + 1)

        if chosen_bet == 0 and die_result == 1:
            reward = bet_rewards[0]
        elif chosen_bet == 1 and die_result in (1, 2, 6, 7):
            reward = bet_rewards[1]
        elif chosen_bet == 2 and die_result % 2 == 0:
            reward = bet_rewards[2]
        else:
            reward = -1

        delta = reward + np.dot(theta, bet_probabilities) - np.dot(theta, [1, 1, 1])

        eligibility_trace = lambda_value * eligibility_trace + bet_probabilities

        theta += alpha * delta * eligibility_trace

        balance += reward

        if reward > 0:
            alpha[chosen_bet] += 1
        else:
            beta[chosen_bet] += 1

        balance_history.append(balance)

    final_balances.append(balance)

    if balance > 100:
        balances_above_100 += 1

average_final_balances = np.mean(final_balances)

squared_differences = np.diff(final_balances) ** 2
mean_squared_difference = np.mean(squared_differences)
root_mean_squared_difference = np.sqrt(mean_squared_difference)

print(f"Average Final Balance Over {num_simulations} Simulations: ${average_final_balances}")
print(f"Frequency of Balances Above $100: {balances_above_100} out of {num_simulations} simulations")
print("Root Mean Squared Difference of Final Balances:", root_mean_squared_difference)

average_bet_choices = np.mean(bet_choices, axis=0)
print("Average number of times each bet was chosen:")
print(f"Single number bet: {average_bet_choices[0]}")
print(f"Corner bet: {average_bet_choices[1]}")
print(f"Even bet: {average_bet_choices[2]}")